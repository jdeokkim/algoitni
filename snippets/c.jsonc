//
//    Copyright (c) 2022-2023 Jaedeok Kim (https://github.com/jdeokkim)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy
//    of this software and associated documentation files (the "Software"), to deal
//    in the Software without restriction, including without limitation the rights
//    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//    copies of the Software, and to permit persons to whom the Software is
//    furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all
//    copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//    SOFTWARE.
//

{
    "c-main": {
        "prefix": "!c-main",
        "body": [
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "",
            "int main(void) {",
            "\t/* TODO: ... */",
            "",
            "\treturn 0;",
            "}"
        ],
    },
    "c-compare": {
        "prefix": "!c-compare",
        "body": [
            "int compare_values(const void *a, const void *b) {",
            "\t${1:int} x = *(const ${2:int} *) a;",
            "\t${3:int} y = *(const ${4:int} *) b;",
            "",
            "\treturn (${5:x} > ${6:y}) - (${7:x} < ${8:y});",
            "}"
        ]
    },
    "c-graph-list": {
        "prefix": "!c-graph-list",
        "body": [
            "#define GRAPH_ELEMENT_TYPE   ${1:int}",
            "#define GRAPH_INIT_CAPACITY  ${2:8}",
            "",
            "typedef struct {",
            "\tstruct {",
            "\t\tGRAPH_ELEMENT_TYPE *ptr;",
            "\t\tint capacity, length;",
            "\t} *adjacency;",
            "\tint *visited, V;",
            "} Graph;",
            "",
            "Graph *graph_create(int V) {",
            "\tGraph *g = malloc(sizeof *g);",
            "",
            "\tg->V = V + 1, g->visited = calloc(g->V, sizeof *(g->visited));",
            "\tg->adjacency = malloc(g->V * sizeof *(g->adjacency));",
            "",
            "\tfor (int i = 0; i < g->V; i++) {",
            "\t\tg->adjacency[i].capacity = GRAPH_INIT_CAPACITY;",
            "\t\tg->adjacency[i].length = 0;",
            "",
            "\t\tg->adjacency[i].ptr = malloc(",
            "\t\t\tg->adjacency[i].capacity * sizeof *(g->adjacency[i].ptr)",
            "\t\t);",
            "\t}",
            "",
            "\treturn g;",
            "}",
            "",
            "void graph_release(Graph *g) {",
            "\tif (g == NULL) return;",
            "",
            "\tfor (int i = 0; i < g->V; i++) free(g->adjacency[i].ptr);",
            "",
            "\tfree(g->adjacency), free(g->visited), free(g);",
            "}",
            "",
            "void graph_add_edge(Graph *g, int u, int v) {",
            "\tif (g == NULL) return;",
            "",
            "\tif (g->adjacency[u].length >= g->adjacency[u].capacity)",
            "\t\tg->adjacency[u].ptr = realloc(",
            "\t\t\tg->adjacency[u].ptr,",
            "\t\t\t(g->adjacency[u].capacity *= 2) * sizeof *(g->adjacency[u].ptr)",
            "\t\t);",
            "",
            "\tif (g->adjacency[v].length >= g->adjacency[v].capacity)",
            "\t\tg->adjacency[v].ptr = realloc(",
            "\t\t\tg->adjacency[v].ptr,",
            "\t\t\t(g->adjacency[v].capacity *= 2) * sizeof *(g->adjacency[v].ptr)",
            "\t\t);",
            "",
            "\tg->adjacency[u].ptr[g->adjacency[u].length++] = (GRAPH_ELEMENT_TYPE) v;",
            "\tg->adjacency[v].ptr[g->adjacency[v].length++] = (GRAPH_ELEMENT_TYPE) u;",
            "}"
        ]
    },
    "c-heap": {
        "prefix": "!c-heap",
        "body": [
            "#define HEAP_ELEMENT_TYPE   ${1:int}",
            "#define HEAP_INIT_CAPACITY  ${2:8}",
            "",
            "typedef struct {",
            "\tHEAP_ELEMENT_TYPE *ptr;",
            "\tint capacity, length;",
            "} Heap;",
            "",
            "Heap *heap_create(void) {",
            "\tHeap *h = malloc(sizeof *h);",
            "",
            "\th->capacity = HEAP_INIT_CAPACITY, h->length = 0;",
            "\th->ptr = malloc(h->capacity * sizeof *(h->ptr));",
            "",
            "\treturn h;",
            "}",
            "",
            "void heap_release(Heap *h) {",
            "\tif (h != NULL) free(h->ptr);",
            "",
            "\tfree(h);",
            "}",
            "",
            "void heap_insert(Heap *h, HEAP_ELEMENT_TYPE v) {",
            "\tif (h == NULL) return;",
            "",
            "\tif (h->length >= h->capacity)",
            "\t\th->ptr = realloc(",
            "\t\t\th->ptr,",
            "\t\t\t(h->capacity *= 2) * sizeof *(h->ptr)",
            "\t\t);",
            "",
            "\th->ptr[++h->length] = v;",
            "",
            "\t{",
            "\t\tint k = h->length;",
            "",
            "\t\twhile (${3:h->ptr[k] < h->ptr[k / 2]}) {",
            "\t\t\tHEAP_ELEMENT_TYPE t = h->ptr[k];",
            "",
            "\t\t\th->ptr[k] = h->ptr[k / 2];",
            "\t\t\th->ptr[k / 2] = t;",
            "",
            "\t\t\tk /= 2;",
            "\t\t}",
            "\t}",
            "}",
            "",
            "HEAP_ELEMENT_TYPE heap_delete_root(Heap *h) {",
            "\tif (h == NULL) return (HEAP_ELEMENT_TYPE) ${4:-1};",
            "",
            "\tHEAP_ELEMENT_TYPE root = h->ptr[1];",
            "",
            "\th->ptr[1] = h->ptr[h->length];",
            "\th->ptr[h->length] = root;",
            "",
            "\th->length--;",
            "",
            "\tint k = 1;",
            "",
            "\twhile ((k * 2) <= h->length) {",
            "\t\tint j = k * 2;",
            "",
            "\t\tif (j < h->length && ${5:h->ptr[j] > h->ptr[j + 1]}) j++;",
            "\t\tif (${6:h->ptr[k] <= h->ptr[j]}) break;",
            "",
            "\t\tHEAP_ELEMENT_TYPE t = h->ptr[k];",
            "",
            "\t\th->ptr[k] = h->ptr[j];",
            "\t\th->ptr[j] = t;",
            "",
            "\t\tk = j;",
            "\t}",
            "",
            "\treturn root;",
            "}",
            "",
            "int heap_is_empty(Heap *h) {",
            "\treturn (h == NULL) || (h->length <= 0);",
            "}"
        ]
    },
    "c-ring-buffer": {
        "prefix": "!c-ring-buffer",
        "body": [
            "#define RING_BUFFER_ELEMENT_TYPE ${1:int}",
            "",
            "typedef struct {",
            "\tRING_BUFFER_ELEMENT_TYPE *ptr;",
            "\tint capacity, start, end;",
            "} RingBuffer;",
            "",
            "RingBuffer *rb_create(int C) {",
            "\tRingBuffer *rb = malloc(sizeof *rb);",
            "",
            "\trb->start = rb->end = 0, rb->capacity = C + 1;",
            "\trb->ptr = malloc(rb->capacity * sizeof *(rb->ptr));",
            "",
            "\treturn rb;",
            "}",
            "",
            "void rb_release(RingBuffer *rb) {",
            "\tif (rb != NULL) free(rb->ptr);",
            "",
            "\tfree(rb);",
            "}",
            "",
            "int rb_is_empty(RingBuffer *rb) {",
            "\treturn (rb == NULL) || (rb->start == rb->end);",
            "}",
            "",
            "int rb_is_full(RingBuffer *rb) {",
            "\treturn (rb != NULL) && (rb->start == (rb->end + 1) % rb->capacity);",
            "}",
            "",
            "void rb_enqueue(RingBuffer *rb, RING_BUFFER_ELEMENT_TYPE v) {",
            "\tif (rb == NULL || rb_is_full(rb)) return;",
            "",
            "\trb->ptr[rb->end] = v;",
            "",
            "\trb->end = (rb->end + 1) % rb->capacity;",
            "}",
            "",
            "RING_BUFFER_ELEMENT_TYPE rb_dequeue(RingBuffer *rb) {",
            "\tif (rb_is_empty(rb)) return (RING_BUFFER_ELEMENT_TYPE) ${2:-1};",
            "",
            "\tRING_BUFFER_ELEMENT_TYPE v = rb->ptr[rb->start];",
            "",
            "\trb->start = (rb->start + 1) % rb->capacity;",
            "",
            "\treturn v;",
            "}"
        ]
    },
    "c-union-find": {
        "prefix": "!c-union-find",
        "body": [
            "typedef struct {",
            "\tint *id, *size, count;",
            "} UnionFind;",
            "",
            "UnionFind *uf_create(int n) {",
            "\tUnionFind *uf = malloc(sizeof *uf);",
            "",
            "\tuf->id = malloc(n * sizeof *(uf->id));",
            "\tuf->size = malloc(n * sizeof *(uf->size));",
            "",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tuf->id[i] = i, uf->size[i] = 1;",
            "",
            "\treturn uf;",
            "}",
            "",
            "void uf_release(UnionFind *uf) {",
            "\tif (uf == NULL) return;",
            "",
            "\tfree(uf->id), free(uf->size), free(uf);",
            "}",
            "",
            "int uf_connected(UnionFind *uf, int p, int q) {",
            "\tif (uf == NULL) return 0;",
            "",
            "\treturn uf_find(uf, p) == uf_find(uf, q);",
            "}",
            "",
            "void uf_unite(UnionFind *uf, int p, int q) {",
            "\tif (uf == NULL) return;",
            "",
            "\tint i = uf_find(uf, p), j = uf_find(uf, q);",
            "",
            "\tif (i == j) return;",
            "",
            "\tif (uf->size[i] < uf->size[j]) uf->id[i] = j, uf->size[j] += uf->size[i];",
            "\telse uf->id[j] = i, uf->size[i] += uf->size[j]; ",
            "",
            "\tuf->count--;",
            "}",
            "",
            "int uf_find(UnionFind *uf, int p) {",
            "\tif (uf == NULL) return -1;",
            "",
            "\t/*",
            "\t\twhile (p != uf->id[p]) p = uf->id[p];",
            "\t\t",
            "\t\treturn p;",
            "\t*/",
            "",
            "\tif (p == uf->id[p]) return p;",
            "",
            "\t// weighted quick-union with path compression",
            "\treturn uf->id[p] = uf_find(uf, uf->id[p]);",
            "}"
        ]
    }
}