//
//    Copyright (c) 2022-2023 Jaedeok Kim (https://github.com/jdeokkim)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy
//    of this software and associated documentation files (the "Software"), to deal
//    in the Software without restriction, including without limitation the rights
//    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//    copies of the Software, and to permit persons to whom the Software is
//    furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all
//    copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//    SOFTWARE.
//

{
    "c-main": {
        "prefix": "!c-main",
        "body": [
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "",
            "int main(void) {",
            "\t/* TODO: ... */",
            "",
            "\treturn 0;",
            "}"
        ]
    },
    "c-force-inline": {
        "prefix": "!c-force-inline",
        "body": [
            "#ifdef _MSC_VER",
            "\t#define FORCE_INLINE __forceinline",
            "#elif defined(__GNUC__)",
            "\t#if defined(__STRICT_ANSI__)",
            "\t\t#define FORCE_INLINE __inline__ __attribute__((always_inline))",
            "\t#else",
            "\t\t#define FORCE_INLINE inline __attribute__((always_inline))",
            "\t#endif",
            "#else",
            "\t#define FORCE_INLINE inline",
            "#endif"
        ]
    },
    "c-geom-aabb": {
        "prefix": "!c-geom-aabb",
        "body": [
            "Rectangle poly_get_aabb(Polygon *s) {",
            "\tif (s == NULL || s->n <= 2) return (Rectangle) { 0 };",
            "",
            "\tVector2 min = s->vertices[0], max = min;",
            "",
            "\tfor (int i = 1; i < s->n; i++) {",
            "\t\tif (min.x > s->vertices[i].x) min.x = s->vertices[i].x;",
            "\t\tif (min.y > s->vertices[i].y) min.y = s->vertices[i].y;",
            "\t\t\t",
            "\t\tif (max.x < s->vertices[i].x) max.x = s->vertices[i].x;",
            "\t\tif (max.y < s->vertices[i].y) max.y = s->vertices[i].y;",
            "\t}",
            "",
            "\treturn (Rectangle) { min.x, min.y, max.x - min.x, max.y - min.y };",
            "}"
        ]
    },
    "c-geom-ccw": {
        "prefix": "!c-geom-ccw",
        "body": [
            "inline int vector2_ccw(Vector2 v1, Vector2 v2, Vector2 v3) {",
            "\tconst ${1:int} lhs = (v3.y - v1.y) * (v2.x - v1.x);",
            "\tconst ${2:int} rhs = (v2.y - v1.y) * (v3.x - v1.x);",
            "",
            "\t// NOTE: `-1` if clockwise, `0` if collinear, `1` if counter-clockwise",
            "\treturn (lhs > rhs) - (lhs < rhs);",
            "}"
        ]
    },
    "c-geom-lines": {
        "prefix": "!c-geom-lines",
        "body": [
            "typedef struct { Vector2 origin, direction; } Ray;",
            "",
            "int compute_intersection_rays(Ray m, Ray n, float *_t) {",
            "\tconst float rXs = vector2_cross(m.direction, n.direction);",
            "",
            "\tconst Vector2 qp = vector2_subtract(n.origin, m.origin);",
            "",
            "\tconst float qpXs = vector2_cross(qp, n.direction);",
            "\tconst float qpXr = vector2_cross(qp, m.direction);",
            "",
            "\tif (rXs != 0.0f) {",
            "\t\tconst float _rXs = 1.0f / rXs;",
            "",
            "\t\tconst float t = qpXs * _rXs, u = qpXr * _rXs;",
            "",
            "\t\tif ((t >= 0.0f && t <= 1.0f) && (u >= 0.0f && u <= 1.0f)) {",
            "\t\t\tif (_t != NULL) *_t = t;",
            "",
            "\t\t\treturn 1;",
            "\t\t}",
            "",
            "\t\treturn 0;",
            "\t} else {",
            "\t\tif (qpXr != 0.0f) return 0;",
            "",
            "\t\tconst float rDr = vector2_dot(m.direction, m.direction);",
            "\t\tconst float sDr = vector2_dot(n.direction, m.direction);",
            "",
            "\t\tconst float _rDr = 1.0f / rDr;",
            "",
            "\t\tconst float qpDr = vector2_dot(qp, m.direction);",
            "",
            "\t\tfloat k, t0 = qpDr * _rDr, t1 = t0 + sDr * _rDr;",
            "",
            "\t\tif (sDr < 0.0f) k = t0, t0 = t1, t1 = k;",
            "",
            "\t\tif ((t0 < 0.0f && t1 == 0.0f) || (t0 == 1.0f && t1 > 1.0f)) {",
            "\t\t\tif (_t != NULL) *_t = (t0 == 1.0f) ? 1.0f : 0.0f;",
            "",
            "\t\t\treturn 1;",
            "\t\t}",
            "",
            "\t\treturn 2 * (t1 >= 0.0 && t0 <= 1.0);",
            "\t}",
            "}"
        ]
    },
    "c-geom-pic": {
        "prefix": "!c-geom-pic",
        "body": [
            "int point_in_convex(Polygon *s, Vector2 p) {",
            "\tif (s == NULL || s->n < 3) return 0;",
            "",
            "\tconst int c1 = vector2_ccw(s->vertices[0], p, s->vertices[1]);",
            "\tconst int c2 = vector2_ccw(s->vertices[0], p, s->vertices[s->n - 1]);",
            "",
            "\tif (c1 > 0 || c2 < 0) return 0;",
            "",
            "\tint low = 0, high = s->n - 1;",
            "",
            "\twhile (high - low > 1) {",
            "\t\tconst int mid = low + (high - low) / 2;",
            "",
            "\t\tif (vector2_ccw(s->vertices[0], p, s->vertices[mid]) > 0) high = mid;",
            "\t\telse low = mid;",
            "\t}",
            "",
            "\tconst int r1 = vector2_ccw(s->vertices[0], p, s->vertices[low]);",
            "\tconst int r2 = vector2_ccw(s->vertices[low], p, s->vertices[low + 1]);",
            "\tconst int r3 = vector2_ccw(s->vertices[low + 1], p, s->vertices[0]);",
            "",
            "\tif ((!r1 && !r2) || (!r1 && !r3) || (!r2 && !r3)) return -1;",
            "",
            "\tif ((low == 1 && !r1 && (r2 * r3 >= 0))",
            "\t\t|| (low + 1 == s->n - 1 && !r3 && (r1 * r2 >= 0))",
            "\t\t|| (!r2 && (r1 * r3 >= 0))) return -1;",
            "",
            "\treturn (r1 <= 0 && r2 <= 0 && r3 <= 0);",
            "}"
        ]
    },
    "c-geom-pit": {
        "prefix": "!c-geom-pit",
        "body": [
            "int point_in_triangle(Polygon *s, Vector2 p) {",
            "\tif (s == NULL || s->n != 3) return 0;",
            "",
            "\treturn (vector2_ccw(s->vertices[0], p, s->vertices[1]) <= 0)",
            "\t\t&& (vector2_ccw(s->vertices[1], p, s->vertices[2]) <= 0)",
            "\t\t&& (vector2_ccw(s->vertices[2], p, s->vertices[0]) <= 0);",
            "}"
        ]
    },
    "c-geom-poly": {
        "prefix": "!c-geom-poly",
        "body": [
            "#define MAX_VERTEX_COUNT  ${1:8}",
            "",
            "typedef struct { ",
            "\tVector2 vertices[MAX_VERTEX_COUNT];",
            "\tint n;",
            "} Polygon;"
        ]
    },
    "c-geom-vec2": {
        "prefix": "!c-geom-vec2",
        "body": [
            "#ifndef RAYLIB_H",
            "typedef struct { float x, y; } Vector2;",
            "#endif",
            "",
            "inline Vector2 vector2_add(Vector2 v1, Vector2 v2) {",
            "\treturn (Vector2) { v1.x + v2.x, v1.y + v2.y };",
            "}",
            "",
            "inline Vector2 vector2_subtract(Vector2 v1, Vector2 v2) {",
            "\treturn (Vector2) { v1.x - v2.x, v1.y - v2.y };",
            "}",
            "",
            "inline Vector2 vector2_scalar_multiply(Vector2 v, float s) {",
            "\treturn (Vector2) { v.x * s, v.y * s };",
            "}",
            "",
            "inline float vector2_cross(Vector2 v1, Vector2 v2) {",
            "\treturn (v1.x * v2.y) - (v1.y * v2.x);",
            "}",
            "",
            "inline float vector2_dot(Vector2 v1, Vector2 v2) {",
            "\treturn (v1.x * v2.x) + (v1.y * v2.y);",
            "}"
        ]
    },
    "c-graph-fill": {
        "prefix": "!c-graph-fill",
        "body": [
            "typedef struct { int x, y; } Point;",
            "",
            "typedef struct {",
            "\tchar **ptr, **visited;",
            "\tint width, height;",
            "} Grid;",
            "",
            "static const int DELTA_X[4] = { 0, 1, 0, -1 }, DELTA_Y[4] = { 1, 0, -1, 0 };",
            "",
            "Grid *grid_create(int w, int h) {",
            "\tGrid *g = malloc(sizeof *g);",
            "",
            "\tg->width = w, g->height = h;",
            "\t",
            "\tg->ptr = malloc(h * sizeof *(g->ptr));",
            "\tg->visited = malloc(h * sizeof *(g->visited));",
            "",
            "\tfor (int i = 0; i < h; i++) {",
            "\t\tg->ptr[i] = malloc(w * sizeof **(g->ptr));",
            "\t\tg->visited[i] = malloc(w * sizeof **(g->visited));",
            "\t}",
            "",
            "\treturn g;",
            "}",
            "",
            "void grid_release(Grid *g) {",
            "\tif (g == NULL) return;",
            "",
            "\tfor (int i = 0; i < g->height; i++) ",
            "\t\tfree(g->visited[i]), free(g->ptr[i]);",
            "",
            "\tfree(g->visited), free(g->ptr), free(g);",
            "}",
            "",
            "void grid_reset(Grid *g) {",
            "\tif (g == NULL) return;",
            "",
            "\tfor (int y = 0; y < g->height; y++)",
            "\t\tfor (int x = 0; x < g->width; x++)",
            "\t\t\tg->visited[y][x] = 0; ",
            "}",
            "",
            "void grid_dfs(Grid *g, Point p) {",
            "\tif (g == NULL) return;",
            "",
            "\tg->visited[p.y][p.x] = 1;",
            "",
            "\tfor (int i = 0; i < 4; i++) {",
            "\t\tconst Point q = { p.x + DELTA_X[i], p.y + DELTA_Y[i] };",
            "",
            "\t\tif (q.x < 0 || q.x >= g->width || q.y < 0 || q.y >= g->height)",
            "\t\t\tcontinue;",
            "",
            "\t\tif (g->ptr[q.y][q.x] && !g->visited[q.y][q.x]) grid_dfs(g, q);",
            "\t}",
            "}"
        ]
    },
    "c-graph-list": {
        "prefix": "!c-graph-list",
        "body": [
            "#define GRAPH_ELEMENT_TYPE   ${1:int}",
            "#define GRAPH_INIT_CAPACITY  ${2:8}",
            "",
            "typedef struct {",
            "\tstruct {",
            "\t\tGRAPH_ELEMENT_TYPE *ptr;",
            "\t\tint capacity, length;",
            "\t} *adjacency;",
            "\tint *visited, V;",
            "} Graph;",
            "",
            "Graph *graph_create(int V) {",
            "\tGraph *g = malloc(sizeof *g);",
            "",
            "\tg->V = V + 1, g->visited = calloc(g->V, sizeof *(g->visited));",
            "\tg->adjacency = malloc(g->V * sizeof *(g->adjacency));",
            "",
            "\tfor (int i = 0; i < g->V; i++) {",
            "\t\tg->adjacency[i].capacity = GRAPH_INIT_CAPACITY;",
            "\t\tg->adjacency[i].length = 0;",
            "",
            "\t\tg->adjacency[i].ptr = malloc(",
            "\t\t\tg->adjacency[i].capacity * sizeof *(g->adjacency[i].ptr)",
            "\t\t);",
            "\t}",
            "",
            "\treturn g;",
            "}",
            "",
            "void graph_release(Graph *g) {",
            "\tif (g == NULL) return;",
            "",
            "\tfor (int i = 0; i < g->V; i++) free(g->adjacency[i].ptr);",
            "",
            "\tfree(g->adjacency), free(g->visited), free(g);",
            "}",
            "",
            "void graph_add_edge(Graph *g, int u, int v) {",
            "\tif (g == NULL) return;",
            "",
            "\tif (g->adjacency[u].length >= g->adjacency[u].capacity)",
            "\t\tg->adjacency[u].ptr = realloc(",
            "\t\t\tg->adjacency[u].ptr,",
            "\t\t\t(g->adjacency[u].capacity *= 2) * sizeof *(g->adjacency[u].ptr)",
            "\t\t);",
            "",
            "\tif (g->adjacency[v].length >= g->adjacency[v].capacity)",
            "\t\tg->adjacency[v].ptr = realloc(",
            "\t\t\tg->adjacency[v].ptr,",
            "\t\t\t(g->adjacency[v].capacity *= 2) * sizeof *(g->adjacency[v].ptr)",
            "\t\t);",
            "",
            "\tg->adjacency[u].ptr[g->adjacency[u].length++] = (GRAPH_ELEMENT_TYPE) v;",
            "\tg->adjacency[v].ptr[g->adjacency[v].length++] = (GRAPH_ELEMENT_TYPE) u;",
            "}"
        ]
    },
    "c-heap-min": {
        "prefix": "!c-heap-min",
        "body": [
            "#define HEAP_ELEMENT_TYPE   ${1:int}",
            "#define HEAP_INIT_CAPACITY  ${2:8}",
            "",
            "typedef struct {",
            "\tHEAP_ELEMENT_TYPE *ptr;",
            "\tint capacity, length;",
            "} Heap;",
            "",
            "Heap *heap_create(void) {",
            "\tHeap *h = malloc(sizeof *h);",
            "",
            "\th->capacity = HEAP_INIT_CAPACITY, h->length = 0;",
            "\th->ptr = calloc(h->capacity, sizeof *(h->ptr));",
            "",
            "\treturn h;",
            "}",
            "",
            "void heap_release(Heap *h) {",
            "\tif (h != NULL) free(h->ptr);",
            "",
            "\tfree(h);",
            "}",
            "",
            "void heap_insert(Heap *h, HEAP_ELEMENT_TYPE v) {",
            "\tif (h == NULL) return;",
            "",
            "\tif (h->length >= h->capacity)",
            "\t\th->ptr = realloc(",
            "\t\t\th->ptr,",
            "\t\t\t(h->capacity *= 2) * sizeof *(h->ptr)",
            "\t\t);",
            "",
            "\th->ptr[++h->length] = v;",
            "",
            "\t{",
            "\t\tint k = h->length;",
            "",
            "\t\twhile (k > 1 && ${3:h->ptr[k] < h->ptr[k / 2]}) {",
            "\t\t\tHEAP_ELEMENT_TYPE t = h->ptr[k];",
            "",
            "\t\t\th->ptr[k] = h->ptr[k / 2];",
            "\t\t\th->ptr[k / 2] = t;",
            "",
            "\t\t\tk /= 2;",
            "\t\t}",
            "\t}",
            "}",
            "",
            "HEAP_ELEMENT_TYPE heap_delete_root(Heap *h) {",
            "\tif (h == NULL) return (HEAP_ELEMENT_TYPE) ${4:-1};",
            "",
            "\tHEAP_ELEMENT_TYPE root = h->ptr[1];",
            "",
            "\th->ptr[1] = h->ptr[h->length];",
            "\th->ptr[h->length] = root;",
            "",
            "\th->length--;",
            "",
            "\tint k = 1;",
            "",
            "\twhile ((k * 2) <= h->length) {",
            "\t\tint j = k * 2;",
            "",
            "\t\tif (j < h->length && ${5:h->ptr[j] > h->ptr[j + 1]}) j++;",
            "\t\tif (${6:h->ptr[k] <= h->ptr[j]}) break;",
            "",
            "\t\tHEAP_ELEMENT_TYPE t = h->ptr[k];",
            "",
            "\t\th->ptr[k] = h->ptr[j];",
            "\t\th->ptr[j] = t;",
            "",
            "\t\tk = j;",
            "\t}",
            "",
            "\treturn root;",
            "}",
            "",
            "int heap_is_empty(Heap *h) {",
            "\treturn (h == NULL) || (h->length <= 0);",
            "}"
        ]
    },
    "c-ring-buffer": {
        "prefix": "!c-ring-buffer",
        "body": [
            "#define RING_BUFFER_ELEMENT_TYPE ${1:int}",
            "",
            "typedef struct {",
            "\tRING_BUFFER_ELEMENT_TYPE *ptr;",
            "\tint capacity, start, end;",
            "} RingBuffer;",
            "",
            "RingBuffer *rb_create(int C) {",
            "\tRingBuffer *rb = malloc(sizeof *rb);",
            "",
            "\trb->start = rb->end = 0, rb->capacity = C + 1;",
            "\trb->ptr = malloc(rb->capacity * sizeof *(rb->ptr));",
            "",
            "\treturn rb;",
            "}",
            "",
            "void rb_release(RingBuffer *rb) {",
            "\tif (rb != NULL) free(rb->ptr);",
            "",
            "\tfree(rb);",
            "}",
            "",
            "int rb_is_empty(RingBuffer *rb) {",
            "\treturn (rb == NULL) || (rb->start == rb->end);",
            "}",
            "",
            "int rb_is_full(RingBuffer *rb) {",
            "\treturn (rb != NULL) && (rb->start == (rb->end + 1) % rb->capacity);",
            "}",
            "",
            "void rb_enqueue(RingBuffer *rb, RING_BUFFER_ELEMENT_TYPE v) {",
            "\tif (rb == NULL || rb_is_full(rb)) return;",
            "",
            "\trb->ptr[rb->end] = v;",
            "",
            "\trb->end = (rb->end + 1) % rb->capacity;",
            "}",
            "",
            "RING_BUFFER_ELEMENT_TYPE rb_dequeue(RingBuffer *rb) {",
            "\tif (rb_is_empty(rb)) return (RING_BUFFER_ELEMENT_TYPE) ${2:-1};",
            "",
            "\tRING_BUFFER_ELEMENT_TYPE v = rb->ptr[rb->start];",
            "",
            "\trb->start = (rb->start + 1) % rb->capacity;",
            "",
            "\treturn v;",
            "}"
        ]
    },
    "c-sort-cmp": {
        "prefix": "!c-sort-cmp",
        "body": [
            "int compare_values(const void *a, const void *b) {",
            "\t${1:int} x = *(const ${2:int} *) a;",
            "\t${3:int} y = *(const ${4:int} *) b;",
            "",
            "\treturn (${5:x} > ${6:y}) - (${7:x} < ${8:y});",
            "}"
        ]
    },
    "c-union-find": {
        "prefix": "!c-union-find",
        "body": [
            "typedef struct {",
            "\tint *id, *size, count;",
            "} UnionFind;",
            "",
            "UnionFind *uf_create(int n) {",
            "\tUnionFind *uf = malloc(sizeof *uf);",
            "",
            "\tuf->id = malloc(n * sizeof *(uf->id));",
            "\tuf->size = malloc(n * sizeof *(uf->size));",
            "",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tuf->id[i] = i, uf->size[i] = 1;",
            "",
            "\treturn uf;",
            "}",
            "",
            "void uf_release(UnionFind *uf) {",
            "\tif (uf == NULL) return;",
            "",
            "\tfree(uf->id), free(uf->size), free(uf);",
            "}",
            "",
            "int uf_connected(UnionFind *uf, int p, int q) {",
            "\tif (uf == NULL) return 0;",
            "",
            "\treturn uf_find(uf, p) == uf_find(uf, q);",
            "}",
            "",
            "void uf_unite(UnionFind *uf, int p, int q) {",
            "\tif (uf == NULL) return;",
            "",
            "\tint i = uf_find(uf, p), j = uf_find(uf, q);",
            "",
            "\tif (i == j) return;",
            "",
            "\tif (uf->size[i] < uf->size[j]) uf->id[i] = j, uf->size[j] += uf->size[i];",
            "\telse uf->id[j] = i, uf->size[i] += uf->size[j]; ",
            "",
            "\tuf->count--;",
            "}",
            "",
            "int uf_find(UnionFind *uf, int p) {",
            "\tif (uf == NULL) return -1;",
            "",
            "\t/*",
            "\t\twhile (p != uf->id[p]) p = uf->id[p];",
            "\t\t",
            "\t\treturn p;",
            "\t*/",
            "",
            "\tif (p == uf->id[p]) return p;",
            "",
            "\t// NOTE: Weighted quick-union with path compression",
            "\treturn uf->id[p] = uf_find(uf, uf->id[p]);",
            "}"
        ]
    }
}